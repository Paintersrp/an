package echo

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/MakeNowJust/heredoc/v2"
	"github.com/Paintersrp/an/internal/config"
	"github.com/Paintersrp/an/pkg/flags"
	"github.com/Paintersrp/an/pkg/fs/templater"
	"github.com/Paintersrp/an/pkg/fs/zet"
	"github.com/atotto/clipboard"
	"github.com/spf13/cobra"
)

func NewCmdEcho(c *config.Config, t *templater.Templater) *cobra.Command {
	var name string
	var auto bool
	var paste bool

	cmd := &cobra.Command{
		Use:   "echo [message] --target [pin-name] --template [template-name] --auto --paste",
		Short: "Append a message to the pinned file or from the clipboard if --paste is set.",
		Long: heredoc.Doc(`
			The echo command appends a message to the pinned file or from the clipboard if --paste is set.
			If no file is pinned, it returns an error.
			If the --auto flag is set, an autogenerated file will be used instead of a pinned file.
			If the --paste flag is set, the current clipboard content is used as the message.

			Examples:
			  an echo "This is a message."
			  an echo "Add this to the pinned file."
			  an echo "This is a message." --auto
			  an echo --paste
		`),
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			return run(cmd, args, c, t, name, auto, paste)
		},
	}

	cmd.Flags().StringVarP(&name, "name", "n", "", "Named pin to target")
	cmd.Flags().
		BoolVarP(&auto, "auto", "a", false, "Generate an autogenerated note rather than using a pin")
	cmd.Flags().
		BoolVarP(&paste, "paste", "p", false, "Use clipboard content as the message")

	flags.AddTemplate(cmd, "echo")

	return cmd
}

func run(
	cmd *cobra.Command,
	args []string,
	c *config.Config,
	t *templater.Templater,
	name string,
	auto bool,
	paste bool,
) error {
	var message string
	var targetPin string
	tmpl := flags.HandleTemplate(cmd)

	if paste {
		var err error
		message, err = clipboard.ReadAll()
		if err != nil {
			return fmt.Errorf("error reading from clipboard: %s", err)
		}
		if message == "" {
			return errors.New("clipboard is empty")
		}
	} else {
		if len(args) == 0 {
			return errors.New("no message provided and --paste not set")
		}
		message = strings.Join(args, " ")
	}

	if auto {
		var title string
		// Generate an autogenerated file name
		title, targetPin = generateFileName(c)

		note := zet.NewZettelkastenNote(
			c.VaultDir,
			"echoes",
			title,
			[]string{"echo"},
			nil,
			"",
		)

		conflict := note.HandleConflicts()
		if conflict != nil {
			// HandleConflicts prints feedback if an error is encountered
			return fmt.Errorf("%s", conflict)
		}

		_, err := note.Create(tmpl, t)
		if err != nil {
			fmt.Printf("error creating note file: %s", err)
			os.Exit(1)
		}

		fmt.Printf("Autogenerated file created: %s\n", targetPin)
	} else {
		if name != "" {
			if c.NamedPins[name] == "" {
				return fmt.Errorf(
					"no file pinned for the name '%s'. Use the pin command to pin a file first",
					name,
				)
			}
			targetPin = c.NamedPins[name]
		} else {
			if c.PinnedFile == "" {
				return errors.New(
					"no file pinned. Use the pin command to pin a file first",
				)
			}
			targetPin = c.PinnedFile
		}
	}

	// Append the message to the target file
	file, err := os.OpenFile(
		targetPin+".md",
		os.O_APPEND|os.O_CREATE|os.O_WRONLY,
		0644,
	)
	if err != nil {
		return err
	}
	defer file.Close()

	if _, err := file.WriteString("\n" + message + "\n"); err != nil {
		return err
	}

	if auto {
		fmt.Printf("Message appended to the autogenerated file %s.\n", targetPin)
	} else if name != "" {
		fmt.Printf("Message appended to the named pinned file %s.\n", name)
	} else {
		fmt.Println("Message appended to the pinned file.")
	}
	return nil
}

func generateFileName(cfg *config.Config) (string, string) {
	// Use the VaultDir from the config and append the "echoes" subdirectory
	baseDir := filepath.Join(cfg.VaultDir, "echoes")

	// Create the "echoes" directory if it doesn't exist
	err := os.MkdirAll(baseDir, 0755)
	if err != nil {
		// Handle error
		fmt.Println("Error creating directory:", err)
	}

	// Get the current working directory
	cwd, err := os.Getwd()
	if err != nil {
		// Handle error or set a default value for cwd
		cwd = "default"
	}

	// Extract the last part of the working directory path as the context keyword
	contextKeyword := filepath.Base(cwd)

	// Use a shorter date format for the file name
	shortDate := time.Now().Format("01022006_05")

	// Construct the file name with the "echoes" subdirectory, short date, and context keyword
	fileName := fmt.Sprintf(
		"echo_%s_%s.md",
		shortDate,
		contextKeyword,
	)

	// Return the full path to the new file
	return fileName, filepath.Join(baseDir, fileName)
}
